---
layout: post
title: "node.js를 위한 JS < 2편 > - 템플릿 문자열과 객체 리터럴의 변화"
date: 2019-05-03
excerpt: "제로초님 인프런 강의와 다양한 구글링 정보 총 집합"
category: Node
tags: [node, javascript, server]
comments: true
---

<center><H1>node를 위한 템플릿 문자열과 객체 리터럴의 변화</H1></center>
<hr>

<br>

## 템플릿 문자열 - 백틱 ( \` )

`ES6`에는 편리한 기능들이 많이 추가되었는데 그 중 하나가 템플릿 문자열이다. `백틱`을 활용해서 문자열을 보다 편리하게 다룰 수 있다. 과연 `백틱`은 무엇일까? 보통은 문자열을 합치거나 새롭게 만들 때 `+`를 많이 사용한다. 먼저 아래 코드를 보자.
```javascript
const a = 'hello';
const b = true;
const c = 3;
const d = a + ' ' + b + ' ' + c; // hello true 3
```
> const 키워드에 대해서 잘 모른다면 [이전 포스팅](https://dnatuna.github.io/nodejs%EC%9D%98-%EA%B8%B0%EB%B3%B82/)을 꼭 읽기 바란다.

보통 저렇게 문자들을 합한다. `+` 기호를 사용하여 문자열로 합칠 때 띄어쓰기가 굉장히 코드를 헷갈리게 만든다. 타이핑이 귀찮기도 하고 보기에도 간결해보이진 않는다. 한마디로 코드의 가독성이 굉장히 떨어진다. 예를 들어
```javascript
const e = a + '의 값은 ' + b + '이고 ' + c + '는 알 수 없습니다.';
// hello의 값은  true이고 3는 알 수 없습니다.
```
이런 식으로 문자열의 길이가 점점 길어지면 길어질수록 불편함이 늘어난다. 물론 위의 예시는 그렇게까지 복잡하진 않다.

새롭게 `ES2015(ES6)`에서는 문자열로 합할 때 \` 이 기호를 사용한다. \` 이건 `백틱`이라고 읽으면 되고 사용법은 굉장히 간단하다. 위의 코드를 합하는 것으로 예시를 보여주겠다.
```javascript
const d = a + ' ' + b + ' ' + c; // hello true 3

const d = `${a} ${b} ${c}`; // hello true 3
```
> 물론 예시처럼 `const`를 두 번 선언하면 에러가 난다. 비교를 위해 편의상 적은 것이니 참고바란다.

변수는 `$`를 앞에 써주고 중괄호로 묶으주면 끝이다. `백틱` 안에 뭐든 쓰면 그것이 전부 문자열이 되는 것이다. 아래 예시를 보면 `백틱`을 사용하는 것이 정말 깔끔하다는 것을 알 수 있다.
```javascript
const e = a + '의 값은 ' + b + '이고 ' + c + '는 알 수 없습니다.';
// hello의 값은  true이고 3는 알 수 없습니다.

const e = `${a}의 값은 ${b}이고 ${c}는 알 수 없습니다.`;
// hello의 값은  true이고 3는 알 수 없습니다.
```
`+` 기호가 없어지면서 코드가 굉장히 깔끔하고 직관적으로 보이게 된다. `백틱`은 `+`를 사용할 때 생기는 지저분함을 없애고 가독성을 높여준다.

> 그럼 큰 따움표랑 작은 따움표는 어떻게 써요? 역슬래쉬를 써줘야 하나요? 아님 그냥 써도 되나요?

많은 개발자분들은 작은 따움표나 큰 따움표를 문자열 안에 넣을 때 역슬래쉬를 써주는 것이 습관이 되어있다고 생각한다. 그래서 아마 `백틱`안에서도 이렇게 쓸 것이다.
```javascript
const a = `작은 따움표 \'`;
```
물론 출력은 `"작은 따움표 '"`로 된다. 그렇지만 `백틱`안에서는 역슬래쉬를 굳이 안써줘도 된다.
```javascript
const a = `작은 따움표 \'`;

const a = `작은 따움표 '`;  // 둘 다 결과가 같다.
```
역슬래쉬는 문자열 안에 역슬래쉬를 넣고 싶을 때만 써주면 된다.
```javascript
const b = `\\`; // "\"
```

<br>

## 객체 리터럴의 변화

ES5까지의 JS의 객체는 사실 생각해보면 그닥 불편함이 없다. 기존의 객체 리터럴로 객체를 만드는 예시를 한 번 보자.
```javascript
var sayNode = function(){
  console.log('Node');
};
var es = 'ES';
var oldObject = {                    // 객체 리터럴로 객체 생성
  sayJS: function() {
    console.log('JS');
  },
  sayNode: sayNode,
};

oldObject[es + 6] = 'Fantastic';    // 객체 맴버 동적 추가
                                    // es는 "ES"이므로 ES6라는 새로운 
                                    // 키를 동적으로 추가한 것이다.
```
굉장히 눈에 익숙한 코드이다. 기존의 JS 구조에 대해서 모르시는 분들은 위에 코드의 주석을 보면 JS의 객체 리터럴이란 이런 것이구나! 하고 알 수 있다. JS의 객체는 객체 리터럴 표현을 통해 생성되는데 `{...}` 구조를 갖고 있다. 그 안에 객체의 맴버를 선언하면 된다.

그리고 키 값이 변수인 경우에는 객체 리터럴 안에서 한 번에 선언을 할 수 없었다. 그래서 보면 `[]`안에 변수를 사용한 키 값을 넣고 맴버를 추가한 것을 볼 수 있다. 객체 뒤의 `[]`을 객체의 속성이라고 하는데, 변수가 들어간 키 값을 안에 넣으면 `동적 객체 키`를 추가할 수 있었다.

아래 코드를 보면 감이 잡힐 것이다.
```javascript
oldObject.sayJs();            // Node
oldObject.sayNode();          // JS

console.log(oldObject.ES6);   // Fantastic
```
동적으로 추가한 객체의 맴버까지 제대로 출력이 되는 것을 볼 수 있다. 이것이 `ES6`에서는 굉장히 깔끔하게 바뀌었다.
```javascript
const sayNode = function(){
  console.log('Node');
};
const es = 'ES';
const newObject = {                    // 객체 리터럴로 객체 생성
  sayJS() {                            // 객체 메소드 선언 간편화
    console.log('JS');
  },
  sayNode,                             // 키와 값이 같을 경우
  [es + 6] = 'Fantastic';
};

newObject.sayJs();            // Node
newObject.sayNode();          // JS

console.log(newObject.ES6);   // Fantastic
```
정말 깔끔하게 바뀌었다. 이제 메소드는 그냥 바로 키 값을 함수명으로 두고 선언하면 된다. 이전 코드는 키 값을 적어주고 뒤에 메소드를 선언했다. 그치만 어짜피 객체의 메소드는 누가 봐도 메소드라고 알 수 있기 때문에 굳이 키 값을 적고 익명함수를 또 적는 수고를 하지 않아도 됐다. 이제 키 값 자체를 함수명으로 두고 선언하는 구조로 사용하면 된다.

그리고 객체에는 키랑 값이 같은 경우에 아래와 같이 썼었다.
```javascript
{ data: data, hello: hello }
```
이제 이럴 필요 없이 그냥 
```javascript
{ data, hello }
```
이렇게 쓰면 된다. 동적 키 추가도 마찬가지다. 객체 리터럴 밖에서 선언해야만 했던 것을 이제 객체 리터럴 안에서도 사용할 수 있게 바뀌었다.

모든 구조가 깔끔하게 바뀌고 좀 더 가독성이 좋게 바뀌었다. 바뀐 ES6 구조를 잘 적응해서 사용한다면 코딩 속도는 물론이고, 남에게 보여주는 나의 코드도 깔끔하게 전달할 수 있다.